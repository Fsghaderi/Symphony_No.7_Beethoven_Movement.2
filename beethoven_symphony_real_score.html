<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beethoven Symphony No. 7 - Real Orchestral Score Visualization</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #dddddd;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(26, 26, 26, 0.95);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            max-width: 320px;
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #ffffff;
        }
        
        .legend {
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .color-box {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            margin-right: 10px;
            border: 1px solid #666;
        }
        
        .controls {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        
        .control-item {
            margin: 10px 0;
        }
        
        label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 13px;
        }
        
        input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }
        
        button {
            background: #444;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            margin-top: 5px;
        }
        
        button:hover {
            background: #555;
        }
        
        button:disabled {
            background: #333;
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .audio-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            background: #555;
            color: #fff;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            display: inline-block;
            margin-top: 10px;
        }
        
        .file-label:hover {
            background: #666;
        }
        
        #audio-status {
            margin-top: 10px;
            font-size: 11px;
            color: #888;
        }
        
        #time-display {
            margin-top: 5px;
            font-size: 11px;
            color: #aaa;
        }
        
        .instructions {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #aaa;
        }
        
        .stats {
            margin-top: 10px;
            font-size: 11px;
            color: #888;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            color: #ffffff;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading orchestral score...</div>
        <div style="font-size: 14px; margin-top: 10px; color: #888;">Parsing JSON data</div>
    </div>
    <div id="container"></div>
    
    <div id="info">
        <h1>Beethoven Symphony No. 7</h1>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 10px;">Movement I - Real Score Data</div>
        
        <div class="stats" id="stats">Loading...</div>
        
        <div class="legend">
            <strong style="font-size: 14px;">Instrument Families:</strong>
            <div class="legend-item">
                <div class="color-box" style="background: #4d94ff;"></div>
                <span>Strings</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #ffeb3b;"></div>
                <span>Woodwinds</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #66ff66;"></div>
                <span>Brass</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background: #ff6666;"></div>
                <span>Percussion</span>
            </div>
        </div>
        
        <div style="margin-top: 10px; font-size: 11px; color: #888;">
            <strong>Spatial Mapping:</strong><br>
            • Distance from center = Time<br>
            • Color = Instrument family<br>
            • Brightness = Dynamics<br>
            • Position = Pitch + Family region
        </div>
        
        <div class="audio-section">
            <strong style="font-size: 14px;">Audio Playback:</strong>
            <div style="font-size: 11px; color: #888; margin-top: 5px;">
                Audio will auto-load. Or upload a different file:
            </div>
            <label for="audio-upload" class="file-label">
                Upload Different Audio
            </label>
            <input type="file" id="audio-upload" accept="audio/*">
            <div id="audio-status" style="color: #888;">Loading audio...</div>
            <div class="audio-controls">
                <button id="play-btn" disabled>Play</button>
                <button id="pause-btn" disabled>Pause</button>
                <button id="restart-btn" disabled>Restart</button>
            </div>
            <div id="time-display"></div>
        </div>
        
        <div class="controls">
            <strong style="font-size: 14px;">Toggle Sections:</strong>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="toggle-strings" checked>
                    Strings
                </label>
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="toggle-woodwinds" checked>
                    Woodwinds
                </label>
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="toggle-brass" checked>
                    Brass
                </label>
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="toggle-percussion" checked>
                    Percussion
                </label>
            </div>
            <div class="control-item">
                <label>
                    <input type="checkbox" id="toggle-grid" checked>
                    Time Grid & Connections
                </label>
            </div>
        </div>
        
        <div class="instructions">
            <strong>Controls:</strong><br>
            • Drag to rotate<br>
            • Scroll to zoom<br>
            • Right-drag to pan
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Load and parse the JSON score data
        let scoreData = null;
        let orchestralNotes = [];
        
        fetch('beethoven_symphony_7_mvt1__2_.json')
            .then(response => response.json())
            .then(data => {
                scoreData = data;
                console.log('Score data loaded:', data.metadata.title);
                parseOrchestralScore();
                initVisualization();
            })
            .catch(error => {
                console.error('Error loading JSON:', error);
                document.getElementById('loading').innerHTML = 
                    '<div>Error loading orchestral score</div>' +
                    '<div style="font-size: 14px; margin-top: 10px; color: #ff6666;">Please ensure beethoven_symphony_7_mvt1__2_.json is in the same folder</div>';
            });
        
        function parseOrchestralScore() {
            // Parse the JSON and convert to time-based notes
            const parts = scoreData.parts;
            const tempoMarkings = scoreData.metadata.tempoMarkings;
            
            let totalNotes = 0;
            let maxTime = 0;
            
            parts.forEach(part => {
                const instrumentName = part.name;
                const family = part.instrument.family;
                
                let currentTime = 0;
                let currentTempo = tempoMarkings[0]; // Start with first tempo
                
                part.measures.forEach((measure, measureIndex) => {
                    // Check for tempo changes
                    const tempoChange = tempoMarkings.find(t => t.measure === measure.number);
                    if (tempoChange) {
                        currentTempo = tempoChange;
                    }
                    
                    const beatsPerMinute = currentTempo.bpm;
                    const secondsPerBeat = 60 / beatsPerMinute;
                    
                    measure.events.forEach(event => {
                        if (event.type === 'note') {
                            // Calculate duration in seconds
                            const durationBeats = parseDuration(event.duration);
                            const durationSeconds = durationBeats * secondsPerBeat;
                            
                            // Extract pitch info
                            const pitch = parsePitch(event.pitch);
                            
                            // Get dynamic level
                            const dynamic = event.dynamic || 'mf';
                            const dynamicsValue = parseDynamic(dynamic);
                            
                            orchestralNotes.push({
                                time: currentTime,
                                duration: durationSeconds,
                                pitch: pitch,
                                family: family,
                                instrument: instrumentName,
                                dynamic: dynamicsValue,
                                measure: measure.number
                            });
                            
                            totalNotes++;
                            maxTime = Math.max(maxTime, currentTime + durationSeconds);
                            currentTime += durationSeconds;
                        } else if (event.type === 'rest') {
                            const durationBeats = parseDuration(event.duration);
                            currentTime += durationBeats * secondsPerBeat;
                        }
                    });
                });
            });
            
            // Sort by time
            orchestralNotes.sort((a, b) => a.time - b.time);
            
            console.log(`Parsed ${totalNotes} notes, duration: ${maxTime.toFixed(2)}s`);
            
            // Update stats
            document.getElementById('stats').innerHTML = 
                `<strong>Score Statistics:</strong><br>` +
                `Total notes: ${totalNotes}<br>` +
                `Duration: ${Math.floor(maxTime / 60)}:${Math.floor(maxTime % 60).toString().padStart(2, '0')}<br>` +
                `Instruments: ${parts.length}`;
        }
        
        function parseDuration(duration) {
            const durations = {
                'whole': 4,
                'half': 2,
                'quarter': 1,
                'eighth': 0.5,
                'sixteenth': 0.25,
                'dotted-half': 3,
                'dotted-quarter': 1.5,
                'dotted-eighth': 0.75
            };
            return durations[duration] || 1;
        }
        
        function parsePitch(pitchString) {
            // Extract note name and octave (e.g., "A4" -> {note: "A", octave: 4})
            const match = pitchString.match(/([A-G][#b]?)(\d+)/);
            if (match) {
                return {
                    note: match[1],
                    octave: parseInt(match[2]),
                    midiNote: pitchToMidi(match[1], parseInt(match[2]))
                };
            }
            return { note: 'C', octave: 4, midiNote: 60 };
        }
        
        function pitchToMidi(note, octave) {
            const noteValues = {
                'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
                'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
                'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
            };
            return (octave + 1) * 12 + (noteValues[note] || 0);
        }
        
        function parseDynamic(dynamic) {
            const dynamics = {
                'pp': 0.2, 'p': 0.4, 'mp': 0.5, 'mf': 0.6,
                'f': 0.8, 'ff': 1.0, 'fff': 1.0
            };
            return dynamics[dynamic] || 0.6;
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRotation = { x: 0, y: 0 };
        let cameraDistance = 20;
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            
            const deltaX = e.clientX - previousMousePosition.x;
            const deltaY = e.clientY - previousMousePosition.y;
            
            cameraRotation.y += deltaX * 0.005;
            cameraRotation.x += deltaY * 0.005;
            cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
            
            updateCameraPosition();
            previousMousePosition = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        renderer.domElement.addEventListener('wheel', (e) => {
            e.preventDefault();
            cameraDistance += e.deltaY * 0.01;
            cameraDistance = Math.max(5, Math.min(40, cameraDistance));
            updateCameraPosition();
        });
        
        function updateCameraPosition() {
            camera.position.x = cameraDistance * Math.cos(cameraRotation.x) * Math.sin(cameraRotation.y);
            camera.position.y = cameraDistance * Math.sin(cameraRotation.x);
            camera.position.z = cameraDistance * Math.cos(cameraRotation.x) * Math.cos(cameraRotation.y);
            camera.lookAt(0, 0, 0);
        }
        
        cameraRotation.y = Math.PI / 4;
        cameraRotation.x = Math.PI / 8;
        updateCameraPosition();
        
        // Groups for instruments
        const groups = {
            strings: new THREE.Group(),
            woodwinds: new THREE.Group(),
            brass: new THREE.Group(),
            percussion: new THREE.Group(),
            grid: new THREE.Group(),
            axes: new THREE.Group(),
            connections: new THREE.Group()
        };
        
        Object.values(groups).forEach(group => scene.add(group));
        
        // Create axes
        const axisLength = 8;
        const axisMaterial = new THREE.LineBasicMaterial({ color: 0x555555, linewidth: 2 });
        
        const xAxis = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-axisLength, 0, 0),
            new THREE.Vector3(axisLength, 0, 0)
        ]);
        groups.axes.add(new THREE.Line(xAxis, axisMaterial));
        
        const yAxis = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -axisLength, 0),
            new THREE.Vector3(0, axisLength, 0)
        ]);
        groups.axes.add(new THREE.Line(yAxis, axisMaterial));
        
        const zAxis = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -axisLength),
            new THREE.Vector3(0, 0, axisLength)
        ]);
        groups.axes.add(new THREE.Line(zAxis, axisMaterial));
        
        // Origin marker
        const originGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        const originMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const origin = new THREE.Mesh(originGeometry, originMaterial);
        groups.axes.add(origin);
        
        let noteObjects = [];
        let connectionLines = [];
        let totalDuration = 0;
        
        function initVisualization() {
            if (orchestralNotes.length === 0) return;
            
            totalDuration = Math.max(...orchestralNotes.map(n => n.time + n.duration));
            const maxRadius = 7;
            
            // Create time grid circles
            const numCircles = 8;
            const gridMaterial = new THREE.LineBasicMaterial({ 
                color: 0x444444, 
                transparent: true, 
                opacity: 0.25 
            });
            
            for (let i = 1; i <= numCircles; i++) {
                const radius = (i / numCircles) * maxRadius;
                const points = [];
                for (let j = 0; j <= 64; j++) {
                    const angle = (j / 64) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        radius * Math.cos(angle),
                        0,
                        radius * Math.sin(angle)
                    ));
                }
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                groups.grid.add(new THREE.Line(geometry, gridMaterial));
            }
            
            // Create note objects
            orchestralNotes.forEach((note, index) => {
                const timeRatio = note.time / totalDuration;
                const radius = timeRatio * maxRadius;
                
                // Get family-based position offset
                const familyOffset = getFamilyOffset(note.family);
                
                // Pitch-based angle (spread notes around circle)
                const angle = (note.pitch.midiNote / 127) * Math.PI * 2;
                
                // Position: radial based on time, angular based on pitch, height based on family
                const position = new THREE.Vector3(
                    radius * Math.cos(angle) + familyOffset.x,
                    familyOffset.y + (note.pitch.octave - 4) * 0.3,
                    radius * Math.sin(angle) + familyOffset.z
                );
                
                // Size inversely proportional to dynamics
                const size = (0.12 - note.dynamic * 0.07) * 0.8;
                
                const geometry = new THREE.SphereGeometry(size, 16, 16);
                const color = getFamilyColor(note.family, note.dynamic);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.8
                });
                
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                sphere.visible = false;
                
                const groupName = note.family === 'woodwind' ? 'woodwinds' : 
                                 note.family === 'strings' ? 'strings' :
                                 note.family === 'brass' ? 'brass' : 'percussion';
                
                groups[groupName].add(sphere);
                
                noteObjects.push({
                    mesh: sphere,
                    time: note.time,
                    duration: note.duration,
                    family: note.family,
                    note: note
                });
            });
            
            // Create connections between sequential notes
            for (let i = 0; i < noteObjects.length - 1; i++) {
                const note1 = noteObjects[i];
                const note2 = noteObjects[i + 1];
                
                if (Math.random() > 0.3) { // 70% chance of connection
                    const p1 = note1.mesh.position;
                    const p2 = note2.mesh.position;
                    
                    // Curved connection
                    const midPoint = new THREE.Vector3(
                        (p1.x + p2.x) / 2,
                        (p1.y + p2.y) / 2,
                        (p1.z + p2.z) / 2
                    );
                    
                    const controlPoint = new THREE.Vector3(
                        midPoint.x + (Math.random() - 0.5) * 1.0,
                        midPoint.y + (Math.random() - 0.5) * 1.0,
                        midPoint.z + (Math.random() - 0.5) * 1.0
                    );
                    
                    const curve = new THREE.QuadraticBezierCurve3(p1, controlPoint, p2);
                    const points = curve.getPoints(20);
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    
                    // Determine line style based on time difference
                    const timeDiff = note2.time - note1.time;
                    let lineMaterial;
                    
                    if (timeDiff < 0.2) {
                        // Fast transition - solid bold
                        lineMaterial = new THREE.LineBasicMaterial({ 
                            color: getFamilyColor(note1.family, 0.5),
                            transparent: true,
                            opacity: 0.35
                        });
                    } else {
                        // Slow transition - dashed
                        lineMaterial = new THREE.LineDashedMaterial({ 
                            color: getFamilyColor(note1.family, 0.5),
                            transparent: true,
                            opacity: 0.25,
                            dashSize: 0.1,
                            gapSize: 0.1
                        });
                    }
                    
                    const line = new THREE.Line(geometry, lineMaterial);
                    if (timeDiff >= 0.2) {
                        line.computeLineDistances();
                    }
                    line.visible = false;
                    
                    groups.connections.add(line);
                    connectionLines.push({
                        line: line,
                        startTime: note1.time,
                        endTime: note2.time
                    });
                }
            }
            
            console.log(`Created ${noteObjects.length} notes and ${connectionLines.length} connections`);
            
            // Hide loading message
            document.getElementById('loading').style.display = 'none';
        }
        
        function getFamilyOffset(family) {
            const offsets = {
                'strings': { x: -0.5, y: -0.5, z: 0 },
                'woodwind': { x: 0.5, y: 0.5, z: 0.5 },
                'brass': { x: 0.5, y: 0, z: -0.5 },
                'percussion': { x: 0, y: -1, z: 0 }
            };
            return offsets[family] || { x: 0, y: 0, z: 0 };
        }
        
        function getFamilyColor(family, dynamics) {
            let base, bright;
            
            if (family === 'strings') {
                base = new THREE.Color(0.1, 0.2, 0.5);
                bright = new THREE.Color(0.3, 0.6, 1.0);
            } else if (family === 'woodwind') {
                base = new THREE.Color(0.5, 0.5, 0.0);
                bright = new THREE.Color(1.0, 0.95, 0.2);
            } else if (family === 'brass') {
                base = new THREE.Color(0.1, 0.4, 0.1);
                bright = new THREE.Color(0.4, 1.0, 0.3);
            } else {
                base = new THREE.Color(0.4, 0.0, 0.0);
                bright = new THREE.Color(1.0, 0.2, 0.2);
            }
            
            return new THREE.Color(
                base.r + (bright.r - base.r) * dynamics,
                base.g + (bright.g - base.g) * dynamics,
                base.b + (bright.b - base.b) * dynamics
            );
        }
        
        // Audio functionality
        let audio = null;
        let isPlaying = false;
        
        // Auto-load the symphony audio file
        function autoLoadAudio() {
            audio = new Audio('beethoven_symphony_7.mp3');
            
            audio.addEventListener('loadedmetadata', () => {
                const duration = audio.duration;
                const minutes = Math.floor(duration / 60);
                const seconds = Math.floor(duration % 60);
                
                document.getElementById('audio-status').innerHTML = 
                    `<span style="color: #4CAF50;">✓ Audio loaded: ${minutes}:${seconds.toString().padStart(2, '0')}</span><br>` +
                    `<span style="font-size: 10px; color: #888;">Ready to play!</span>`;
                document.getElementById('play-btn').disabled = false;
                document.getElementById('pause-btn').disabled = false;
                document.getElementById('restart-btn').disabled = false;
            });
            
            audio.addEventListener('error', (e) => {
                console.error('Audio load error:', e);
                document.getElementById('audio-status').innerHTML = 
                    '<span style="color: #ff6666;">Audio file not found in same folder</span><br>' +
                    '<span style="font-size: 10px;">Please upload manually below</span>';
            });
            
            audio.addEventListener('timeupdate', () => {
                const currentTime = audio.currentTime;
                const duration = audio.duration;
                const minutes = Math.floor(currentTime / 60);
                const seconds = Math.floor(currentTime % 60);
                const totalMinutes = Math.floor(duration / 60);
                const totalSeconds = Math.floor(duration % 60);
                
                document.getElementById('time-display').textContent = 
                    `${minutes}:${seconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
            });
            
            audio.addEventListener('ended', () => {
                isPlaying = false;
                document.getElementById('play-btn').textContent = 'Play';
            });
        }
        
        // Try to auto-load audio on page load
        autoLoadAudio();
        
        // Manual upload option as fallback
        // Manual upload option as fallback
        document.getElementById('audio-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                audio = new Audio(url);
                
                audio.addEventListener('loadedmetadata', () => {
                    document.getElementById('audio-status').innerHTML = 
                        `<span style="color: #4CAF50;">✓ Loaded: ${file.name}</span><br>` +
                        `<span style="font-size: 10px; color: #888;">Ready to play!</span>`;
                    document.getElementById('play-btn').disabled = false;
                    document.getElementById('pause-btn').disabled = false;
                    document.getElementById('restart-btn').disabled = false;
                    
                    // Reset visualization
                    noteObjects.forEach(obj => obj.mesh.visible = false);
                    connectionLines.forEach(conn => conn.line.visible = false);
                });
                
                audio.addEventListener('timeupdate', () => {
                    const currentTime = audio.currentTime;
                    const duration = audio.duration;
                    const minutes = Math.floor(currentTime / 60);
                    const seconds = Math.floor(currentTime % 60);
                    const totalMinutes = Math.floor(duration / 60);
                    const totalSeconds = Math.floor(duration % 60);
                    
                    document.getElementById('time-display').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')} / ${totalMinutes}:${totalSeconds.toString().padStart(2, '0')}`;
                });
                
                audio.addEventListener('ended', () => {
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = 'Play';
                });
            }
        });
        
        document.getElementById('play-btn').addEventListener('click', () => {
            if (audio) {
                if (isPlaying) {
                    audio.pause();
                    isPlaying = false;
                    document.getElementById('play-btn').textContent = 'Play';
                } else {
                    audio.play();
                    isPlaying = true;
                    document.getElementById('play-btn').textContent = 'Pause';
                }
            }
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            if (audio) {
                audio.pause();
                isPlaying = false;
                document.getElementById('play-btn').textContent = 'Play';
            }
        });
        
        document.getElementById('restart-btn').addEventListener('click', () => {
            if (audio) {
                audio.currentTime = 0;
                noteObjects.forEach(obj => obj.mesh.visible = false);
                connectionLines.forEach(conn => conn.line.visible = false);
                audio.play();
                isPlaying = true;
                document.getElementById('play-btn').textContent = 'Pause';
            }
        });
        
        function updateVisualization(currentTime) {
            noteObjects.forEach(noteObj => {
                if (noteObj.time <= currentTime && currentTime <= noteObj.time + noteObj.duration + 0.5) {
                    noteObj.mesh.visible = true;
                    
                    // Pulse currently playing notes
                    if (currentTime >= noteObj.time && currentTime <= noteObj.time + noteObj.duration) {
                        const scale = 1.3 + Math.sin(Date.now() * 0.01) * 0.15;
                        noteObj.mesh.scale.set(scale, scale, scale);
                        noteObj.mesh.material.opacity = 0.95;
                    } else {
                        noteObj.mesh.scale.set(1, 1, 1);
                        noteObj.mesh.material.opacity = 0.7;
                    }
                } else if (noteObj.time > currentTime) {
                    noteObj.mesh.visible = false;
                }
            });
            
            connectionLines.forEach(conn => {
                if (conn.endTime <= currentTime) {
                    conn.line.visible = true;
                } else {
                    conn.line.visible = false;
                }
            });
        }
        
        // Toggle controls
        document.getElementById('toggle-strings').addEventListener('change', (e) => {
            groups.strings.visible = e.target.checked;
        });
        
        document.getElementById('toggle-woodwinds').addEventListener('change', (e) => {
            groups.woodwinds.visible = e.target.checked;
        });
        
        document.getElementById('toggle-brass').addEventListener('change', (e) => {
            groups.brass.visible = e.target.checked;
        });
        
        document.getElementById('toggle-percussion').addEventListener('change', (e) => {
            groups.percussion.visible = e.target.checked;
        });
        
        document.getElementById('toggle-grid').addEventListener('change', (e) => {
            groups.grid.visible = e.target.checked;
            groups.connections.visible = e.target.checked;
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (audio && isPlaying && !audio.paused) {
                updateVisualization(audio.currentTime);
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
    </script>
</body>
</html>
